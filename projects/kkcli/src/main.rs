pub mod cli;
pub mod messages;
pub mod transport;
pub mod onboarding;
pub mod server;

use crate::{
    cli::{Cli, CliDebugCommand, Subcommand},
    transport::{ProtocolAdapter, UsbTransport, HidTransport},
};
use anyhow::{anyhow, Result};
use clap::Parser;
use rusb::{Device, GlobalContext};
use std::panic;

const DEVICE_IDS: &[(u16, u16)] = &[(0x2b24, 0x0001), (0x2b24, 0x0002)];

fn list_devices() -> Box<[Device<GlobalContext>]> {
    rusb::devices()
        .unwrap()
        .iter()
        .filter(|device| {
            let device_desc = device.device_descriptor().unwrap();
            DEVICE_IDS.contains(&(device_desc.vendor_id(), device_desc.product_id()))
        })
        .collect()
}

fn get_device() -> Result<Device<GlobalContext>> {
    Ok(list_devices()
        .iter()
        .next()
        .ok_or_else(|| anyhow!("no device found"))?
        .to_owned())
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize detailed tracing for HTTP requests
    std::env::set_var("RUST_LOG", "info,tower_http=debug,axum=debug");
    
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();
    
    // clap needs too much memory to parse things for some reason -- something
    // to do with the code generated by its derive macros I think -- and it's
    // easier to just give it an extra couple of megs than to fix the problem.
    let cli = std::thread::Builder::new()
        .stack_size(4 * 1024 * 1024)
        .spawn(Cli::parse)
        .unwrap()
        .join();
    let cli = match cli {
        Ok(x) => x,
        Err(x) => panic::resume_unwind(x),
    };

    // Check for special commands that don't need device communication
    match &cli.command {
        Subcommand::Onboard(_) => {
            return onboarding::main::run_onboarding_wizard();
        }
        Subcommand::Server(server_cmd) => {
            // Handle server command asynchronously
            return server_cmd.clone().run().await;
        }
        Subcommand::List(_) => {
            for device in list_devices().iter() {
                let device_desc = device.device_descriptor()?;
                let device_handle = device.open()?;
                println!(
                    "Bus {:03} Device {:03} ID {:04x}:{:04x}\t\"{}\"\t({})",
                    device.bus_number(),
                    device.address(),
                    device_desc.vendor_id(),
                    device_desc.product_id(),
                    device_handle.read_product_string_ascii(&device_desc)?,
                    device_handle.read_serial_number_string_ascii(&device_desc)?,
                );
            }
            return Ok(());
        }
        Subcommand::Decode(x) => {
            x.clone().handle()?;
            return Ok(());
        }
        _ => (),
    }
    
    *transport::protocol_adapter::VERBOSE.write().unwrap() = cli.verbose;

    // Check if HID transport is explicitly requested
    if cli.hid {
        eprintln!("Using HID transport (no sudo required)...");
        let mut hid_transport = HidTransport::new(None)?;
        cli.handle_debug(
            &mut hid_transport,
            None, // No debug transport for HID
        )
    } else {
            // Try USB transport first
    let result = get_device()
        .and_then(|device| UsbTransport::new(&device, 0).map_err(|e| anyhow!(e)));
        
        match result {
            Ok((mut transport, config_descriptor, handle)) => {
                // USB transport succeeded
                let mut debug_transport =
                    UsbTransport::new_from_descriptor_and_handle(&config_descriptor, handle, 1).ok();

                cli.handle_debug(
                    &mut transport,
                    debug_transport
                        .as_mut()
                        .map(|x| -> &mut dyn ProtocolAdapter { x }),
                )
            }
            Err(e) => {
                // Check if it's a permission error
                let error_str = e.to_string();
                if error_str.contains("Access denied") || 
                   error_str.contains("insufficient permissions") ||
                   error_str.contains("LIBUSB_ERROR_ACCESS") {
                    eprintln!("USB permission denied, falling back to HID transport...");
                    
                    // Try HID transport as fallback
                    let mut hid_transport = HidTransport::new(None)?;
                    cli.handle_debug(
                        &mut hid_transport,
                        None, // No debug transport for HID
                    )
                } else {
                    // Other error, propagate it
                    Err(e)
                }
            }
        }
    }
}
